<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Digital Whiteboard</title>
<style>
:root{
  --bg:#0f172a; /* slate-900 */
  --panel:#0b1220ee;
  --ink:#e5e7eb; /* default pen */
  --muted:#94a3b8;
  --primary:#22d3ee; /* cyan */
  --accent:#a78bfa; /* violet */
  --warn:#fb7185;   /* rose */
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;background:radial-gradient(1200px 800px at 50% -200px,#1e293b,var(--bg));
  color:#e5e7eb;font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans",sans-serif;
  display:flex;flex-direction:column;overflow:hidden;
}
.header{display:flex;align-items:center;gap:12px;padding:12px 14px;border-bottom:1px solid #1f2937;background:linear-gradient(#0b1220, #0b1220f2);backdrop-filter:blur(8px)}
.logo{font-weight:800;letter-spacing:1px}
.badge{font-size:12px;padding:4px 8px;border:1px solid #334155;border-radius:999px;color:var(--muted)}
.toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.btn{display:inline-flex;align-items:center;gap:8px;cursor:pointer;padding:14px 16px;border-radius:14px;border:1px solid #334155;background:#0b1220;color:#e5e7eb;box-shadow:0 2px 0 #00000055;user-select:none;font-size:16px;line-height:1}
.btn:hover{filter:brightness(1.12)}
.btn.active{outline:2px solid var(--primary);}
.sep{width:1px;height:28px;background:#243041;margin:0 6px}
label{font-size:13px;color:var(--muted)}
input[type="range"]{accent-color:var(--primary)}
.color{width:32px;height:32px;border-radius:8px;border:1px solid #334155;cursor:pointer}
.picker{display:flex;gap:6px;align-items:center}
.right{margin-left:auto;display:flex;gap:8px;align-items:center}

.canvas-wrap{position:relative;flex:1;overflow:hidden}
#grid{position:absolute;inset:0;pointer-events:none;background-size:40px 40px;background-image:linear-gradient(to right,#1f2937 1px,transparent 1px),linear-gradient(to bottom,#1f2937 1px,transparent 1px);opacity:.35}
#board{position:absolute;inset:0;touch-action:none;cursor:crosshair}
.hint{position:absolute;left:12px;bottom:12px;color:var(--muted);background:#0b1220cc;border:1px solid #1f2937;border-radius:10px;padding:8px 10px;backdrop-filter:blur(6px);font-size:13px}
.toast{position:absolute;top:16px;left:50%;transform:translateX(-50%);background:#111827;border:1px solid #1f2937;border-radius:12px;padding:10px 14px;opacity:0;transition:opacity .25s ease}
.toast.show{opacity:1}

/* floating text editor */
.text-editor{position:absolute;z-index:10;display:none}
.text-editor textarea{min-width:320px;min-height:90px;padding:10px 12px;border-radius:12px;border:1px solid #374151;background:#0b1220;color:#e5e7eb;font-size:20px;line-height:1.4}
.text-editor .actions{margin-top:6px;display:flex;gap:6px}

footer{display:flex;gap:12px;align-items:center;justify-content:center;color:var(--muted);padding:8px;border-top:1px solid #1f2937;background:#0b1220}
kbd{background:#111827;padding:2px 5px;border-radius:6px;border:1px solid #374151;color:#e5e7eb;font-size:12px}
</style>
</head>
<body>
  <div class="header">
    <div class="logo">Digital Whiteboard</div>
    <span class="badge">Developed by DennisZ</span>

    <div class="toolbar">
      <button class="btn tool" data-tool="pen" title="ç•«ç­† (P)">âœï¸ ç•«ç­†</button>
      <button class="btn tool" data-tool="highlighter" title="è¢å…‰ç­† (H)">ğŸ–ï¸ è¢å…‰ç­†</button>
      <button class="btn tool" data-tool="eraser" title="æ©¡çš®æ“¦ (E)">ğŸ§½ æ©¡çš®æ“¦</button>
      <div class="sep"></div>
      <button class="btn tool" data-tool="line" title="ç›´ç·š (L)">ğŸ“ ç›´ç·š</button>
      <button class="btn tool" data-tool="rect" title="çŸ©å½¢ (R)">â–­ çŸ©å½¢</button>
      <button class="btn tool" data-tool="text" title="æ–‡å­— (T)">ğŸ”¤ æ–‡å­—</button>
      <button class="btn tool" data-tool="laser" title="é›·å°„ç­† (Z)">ğŸ”´ é›·å°„</button>
      <div class="sep"></div>
      <div class="picker">
        <label>é¡è‰²</label>
        <input type="color" id="color" value="#e5e7eb" class="color" />
      </div>
      <div class="picker">
        <label>ç²—ç´°</label>
        <input type="range" id="size" min="1" max="60" value="6" />
      </div>
      <div class="picker">
        <label><input type="checkbox" id="pressure" checked /> å£“åŠ›æ„Ÿæ‡‰</label>
      </div>
      <div class="sep"></div>
      <button class="btn" id="undo" title="å¾©åŸ (Ctrl+Z)">â†¶ å¾©åŸ</button>
      <button class="btn" id="redo" title="é‡åš (Ctrl+Y)">â†· é‡åš</button>
      <button class="btn" id="clear" title="æ¸…ç©ºçœ‹æ¿">ğŸ—‘ï¸ æ¸…ç©º</button>
      <button class="btn" id="save" title="åŒ¯å‡º PNG">ğŸ’¾ åŒ¯å‡º</button>
      <div class="sep"></div>
      <button class="btn" id="paste" title="è²¼ä¸Šå‰ªè²¼ç°¿ (Ctrl+V)">ğŸ“‹ è²¼ä¸Š</button>
      <button class="btn" id="lockToggle" title="é–å®š/è§£é–å·²é¸å–ç‰©ä»¶">ğŸ”’ é–å®š/è§£é–</button>
    </div>

    <div class="right">
      <button class="btn" id="fullscreen" title="å…¨è¢å¹• (F)">â›¶ å…¨è¢å¹•</button>
      <button class="btn" id="toggleGrid" title="åˆ‡æ›æ ¼ç·š (G)"># æ ¼ç·š</button>
    </div>
  </div>

  <div class="canvas-wrap">
    <div id="grid"></div>
    <canvas id="board"></canvas>
    <div class="text-editor" id="textEditor">
      <textarea id="textInput" placeholder="è¼¸å…¥æ–‡å­—â€¦"></textarea>
      <div class="actions">
        <button class="btn" id="textOk">æ’å…¥</button>
        <button class="btn" id="textCancel">å–æ¶ˆ</button>
      </div>
    </div>
    <div class="hint">å¿«æ·éµï¼š<kbd>P</kbd>ç­† <kbd>H</kbd>è¢å…‰ <kbd>E</kbd>æ“¦ <kbd>L</kbd>ç·š <kbd>R</kbd>çŸ©å½¢ <kbd>T</kbd>æ–‡å­— <kbd>Z</kbd>é›·å°„ï½œ<kbd>Ctrl</kbd>+<kbd>Z</kbd> å¾©åŸ <kbd>Ctrl</kbd>+<kbd>Y</kbd> é‡åšï½œ<kbd>F</kbd> å…¨è¢å¹•ï½œ<kbd>Ctrl</kbd>+<kbd>V</kbd> è²¼ä¸Š</div>
    <div class="toast" id="toast">å·²åŒ¯å‡º PNG æª”</div>
  </div>

  <footer>
    <div>ç•«ç­†æœƒè‡ªå‹•æ ¹æ“š <em>Pointer Events</em> çš„ <code>pressure</code> æ”¹è®Šç²—ç´°ï¼ˆå¯é—œé–‰ï¼‰ã€‚æ”¯æ´è§¸æ§/æ»‘é¼ /æ‰‹å¯«ç­†ã€‚è²¼ä¸Šæ”¯æ´æ–‡å­—èˆ‡åœ–ç‰‡ï¼›è²¼ä¸Šå¾Œå¯æ‹–æ›³ï¼Œä¸¦å¯é–å®šã€‚</div>
  </footer>

<script>
/**
 * Digital Whiteboard V2 â€“ å–®æª”ç‰ˆ
 * + å¤§å°ºå¯¸å·¥å…·æŒ‰éˆ•
 * + è²¼ä¸Šå‰ªè²¼ç°¿æ–‡å­—æˆ–åœ–ç‰‡ï¼ˆCtrl+V / æŒ‰éˆ•ï¼‰
 * + è²¼ä¸Šç‰©ä»¶å¯ç§»å‹•ã€å¯é–å®š/è§£é–ã€å¯åˆªé™¤ï¼ˆDelete/Backspaceï¼‰
 */
const $ = (s)=>document.querySelector(s);
const $$ = (s)=>Array.from(document.querySelectorAll(s));

const canvas = $('#board');
const ctx = canvas.getContext('2d');
const grid = $('#grid');

const tools = ['pen','highlighter','eraser','line','rect','text','laser'];
let tool = 'pen';
let color = $('#color').value;
let size = +$('#size').value;
let pressureEnabled = $('#pressure').checked;
let drawing = false;
let startPoint = null; // for line/rect
let tempShape = null;  // preview frame
let laserTrail = [];

const history = []; // vector ops
let redoStack = [];

// ç‰©ä»¶å±¤ï¼ˆè²¼ä¸Šå¾Œå¯ç§»å‹•/é–å®šï¼‰
const objects = []; // {type:'image'|'textblock', x,y,w,h,img?, text?, color?, size?, locked:false}
let selected = -1;
let draggingObj = false; let dragDX = 0, dragDY = 0;

function resize(){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const {clientWidth:w, clientHeight:h} = canvas.parentElement;
  canvas.width = w * dpr; canvas.height = h * dpr;
  canvas.style.width = w+"px"; canvas.style.height = h+"px";
  ctx.setTransform(dpr,0,0,dpr,0,0);
  render();
}
window.addEventListener('resize', resize);

function setActiveTool(t){ tool = t; $$('.tool').forEach(b=>b.classList.toggle('active', b.dataset.tool===t)); }

// UI binds
$$('.tool').forEach(b=>b.addEventListener('click',()=>setActiveTool(b.dataset.tool)));
$('#color').addEventListener('input', e=>{color=e.target.value;render()});
$('#size').addEventListener('input', e=>{size=+e.target.value});
$('#pressure').addEventListener('change', e=>{pressureEnabled=e.target.checked});
$('#undo').addEventListener('click', undo);
$('#redo').addEventListener('click', redo);
$('#clear').addEventListener('click', ()=>{history.length=0; redoStack.length=0; render()});
$('#save').addEventListener('click', exportPNG);
$('#fullscreen').addEventListener('click', toggleFullscreen);
$('#toggleGrid').addEventListener('click', ()=>{grid.style.display = grid.style.display==='none' ? '' : 'none'});
$('#paste').addEventListener('click', pasteFromClipboard);
$('#lockToggle').addEventListener('click', toggleLock);

// paste via keyboard
window.addEventListener('paste', handlePaste);

// Pointer Events
canvas.addEventListener('pointerdown', onDown);
canvas.addEventListener('pointermove', onMove);
canvas.addEventListener('pointerup', onUp);
canvas.addEventListener('pointercancel', onUp);
canvas.addEventListener('pointerleave', onUp);
canvas.addEventListener('contextmenu', e=>e.preventDefault());

function getPos(e){
  const r = canvas.getBoundingClientRect();
  return {x: e.clientX - r.left, y: e.clientY - r.top, p: e.pressure || 0.5};
}

function onDown(e){
  if(e.button===1) return; // ignore middle
  const pos = getPos(e);
  // å…ˆæª¢æ¸¬ç‰©ä»¶å‘½ä¸­ï¼Œå‘½ä¸­å‰‡é€²å…¥æ‹–æ›³
  const idx = hitObject(pos.x,pos.y);
  if(idx>=0){
    selected = idx; render();
    if(!objects[idx].locked){ draggingObj = true; dragDX = pos.x-objects[idx].x; dragDY = pos.y-objects[idx].y; }
    return; // ä¸é€²å…¥ç•«ç­†æµç¨‹
  }
  canvas.setPointerCapture(e.pointerId);
  drawing = true; startPoint = pos; tempShape = null;
  if(tool==='pen' || tool==='highlighter' || tool==='eraser'){
    const stroke = {type: tool, color, size, points:[{x:pos.x,y:pos.y,p:pos.p}]};
    history.push(stroke); redoStack.length=0; render();
  } else if(tool==='laser') {
    laserTrail.push({x:pos.x,y:pos.y,t:performance.now()});
  } else if(tool==='text'){
    openTextEditor(pos.x,pos.y);
    drawing=false; // æ–‡å­—ç”¨ç·¨è¼¯å™¨æ’å…¥
  }
}

function onMove(e){
  const pos = getPos(e);
  if(draggingObj && selected>=0){
    const o = objects[selected];
    if(!o.locked){ o.x = pos.x - dragDX; o.y = pos.y - dragDY; render(); }
    return;
  }
  if(tool==='laser'){
    laserTrail.push({x:pos.x,y:pos.y,t:performance.now()});
    render();
    return;
  }
  if(!drawing) return;
  if(tool==='pen' || tool==='highlighter' || tool==='eraser'){
    const stroke = history[history.length-1];
    const pressure = pressureEnabled ? Math.max(0.2, pos.p) : 1;
    stroke.points.push({x:pos.x,y:pos.y,p:pressure});
    const coalesced = e.getCoalescedEvents ? e.getCoalescedEvents() : [];
    for(const ce of coalesced){
      const cp = getPos(ce);
      stroke.points.push({x:cp.x,y:cp.y,p: pressureEnabled? Math.max(0.2, cp.p):1});
    }
    render();
  } else if(tool==='line' || tool==='rect'){
    tempShape = {type:tool, start:startPoint, end:pos, color, size};
    render();
  }
}

function onUp(){
  if(draggingObj){ draggingObj=false; return; }
  if(!drawing) return;
  drawing = false;
  if(tempShape){ history.push(tempShape); redoStack.length=0; tempShape=null; render(); }
}

// Drawing
function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // vector history
  for(const op of history){ drawOp(op, ctx); }
  // preview temp
  if(tempShape){ drawOp(tempShape, ctx, true); }
  // objects layer
  drawObjects();
  // laser
  drawLaser();
}

function drawOp(op, c, preview=false){
  if(op.type==='pen' || op.type==='highlighter' || op.type==='eraser'){
    c.save();
    c.lineJoin='round'; c.lineCap='round';
    c.globalCompositeOperation = (op.type==='eraser')? 'destination-out':'source-over';
    c.globalAlpha = (op.type==='highlighter')? 0.28 : 1;
    c.strokeStyle = (op.type==='eraser')? '#000' : op.color;
    c.beginPath();
    for(let i=1;i<op.points.length;i++){
      const a = op.points[i-1], b = op.points[i];
      const w = (op.size) * (pressureEnabled ? (b.p||1) : 1);
      c.lineWidth = Math.max(0.5, w);
      c.moveTo(a.x,a.y); c.lineTo(b.x,b.y);
    }
    c.stroke();
    c.restore();
  }
  if(op.type==='line'){
    c.save(); c.strokeStyle = op.color; c.lineWidth = op.size; c.lineCap='round';
    c.beginPath(); c.moveTo(op.start.x, op.start.y); c.lineTo(op.end.x, op.end.y); c.stroke(); c.restore();
  }
  if(op.type==='rect'){
    c.save(); c.strokeStyle = op.color; c.lineWidth = op.size;
    const x = Math.min(op.start.x, op.end.x);
    const y = Math.min(op.start.y, op.end.y);
    const w = Math.abs(op.start.x - op.end.x);
    const h = Math.abs(op.start.y - op.end.y);
    c.strokeRect(x,y,w,h); c.restore();
  }
  if(op.type==='text'){
    c.save(); c.fillStyle = op.color; c.font = `${op.size||28}px ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto`;
    wrapText(c, op.text, op.x, op.y, 800, 1.35*(op.size||28));
    c.restore();
  }
}

function drawLaser(){
  const now = performance.now();
  const life = 600; // ms
  laserTrail = laserTrail.filter(p=> now - p.t < life);
  const c = ctx; c.save();
  for(const p of laserTrail){
    const k = 1 - (now - p.t)/life;
    c.globalAlpha = Math.max(0, k);
    c.fillStyle = '#ef4444';
    c.beginPath(); c.arc(p.x,p.y,10*k,0,Math.PI*2); c.fill();
  }
  c.restore();
  if(laserTrail.length) requestAnimationFrame(render);
}

// text editor
const editor = $('#textEditor');
const textInput = $('#textInput');
$('#textOk').addEventListener('click', ()=>{
  const text = textInput.value.trim();
  if(text){ history.push({type:'text', text, x: editor.dataset.x|0, y: editor.dataset.y|0, color, size: Math.max(16, size)}); redoStack.length=0; render(); }
  closeTextEditor();
});
$('#textCancel').addEventListener('click', closeTextEditor);
function openTextEditor(x,y){ editor.style.left = x + 'px'; editor.style.top = y + 'px'; editor.dataset.x = x; editor.dataset.y = y; editor.style.display = 'block'; textInput.value=''; textInput.focus(); }
function closeTextEditor(){ editor.style.display='none'; }

// helpers
function undo(){ if(history.length){ redoStack.push(history.pop()); render(); } }
function redo(){ if(redoStack.length){ history.push(redoStack.pop()); render(); } }
function toggleFullscreen(){ if(!document.fullscreenElement){ document.documentElement.requestFullscreen?.(); } else { document.exitFullscreen?.(); } }
function exportPNG(){
  const wasHidden = grid.style.display==='none';
  grid.style.display='none'; render();
  requestAnimationFrame(()=>{
    const a = document.createElement('a'); a.download='whiteboard.png'; a.href = canvas.toDataURL('image/png'); a.click();
    grid.style.display = wasHidden? 'none' : '';
    showToast('å·²åŒ¯å‡º PNG æª”'); render();
  });
}
function showToast(msg){ const t=$('#toast'); t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'), 1200); }

function wrapText(c, text, x, y, maxWidth, lineHeight){
  const words = String(text).split(/\s+/); let line=''; let yy=y; const lines=[];
  for(let n=0;n<words.length;n++){
    const test = line + (line?' ':'') + words[n];
    const w = c.measureText(test).width;
    if(w>maxWidth && n>0){ lines.push({text:line, x, y:yy}); line = words[n]; yy+=lineHeight; }
    else line = test;
  }
  lines.push({text:line, x, y:yy});
  for(const L of lines){ c.fillText(L.text, L.x, L.y); }
  return {w:maxWidth, h:(lines.length-1)*lineHeight};
}

// ===== ç‰©ä»¶å±¤ï¼šç¹ªè£½ã€å‘½ä¸­ã€è²¼ä¸Šã€é–å®š =====
function drawObjects(){
  for(let i=0;i<objects.length;i++){
    const o = objects[i];
    if(o.type==='image' && o.img){ ctx.drawImage(o.img, o.x, o.y, o.w, o.h); }
    if(o.type==='textblock'){
      ctx.save(); ctx.fillStyle = o.color || '#e5e7eb'; ctx.font = `${o.size||24}px ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto`;
      wrapText(ctx, o.text, o.x, o.y, o.w||600, 1.35*(o.size||24));
      ctx.restore();
    }
  }
  if(selected>=0){ drawSelection(objects[selected]); }
}
function drawSelection(o){
  ctx.save(); ctx.setLineDash([6,6]); ctx.lineWidth=2; ctx.strokeStyle = o.locked? '#f87171':'#22d3ee';
  const b = getBounds(o);
  ctx.strokeRect(b.x-4,b.y-4,b.w+8,b.h+8);
  ctx.setLineDash([]); ctx.fillStyle = o.locked? '#f87171':'#22d3ee';
  ctx.beginPath(); ctx.arc(b.x+b.w, b.y-10, 6, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}
function getBounds(o){
  if(o.type==='image'){ return {x:o.x, y:o.y, w:o.w, h:o.h}; }
  if(o.type==='textblock'){
    ctx.save(); ctx.font = `${o.size||24}px ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto`;
    const lineH = 1.35*(o.size||24);
    const words = String(o.text||'').split(/\s+/); let line=''; let lines=1; const maxW = o.w||600;
    for(let i=0;i<words.length;i++){ const t = (line?line+' ':'')+words[i]; if(ctx.measureText(t).width > maxW && i>0){ lines++; line=words[i]; } else { line=t; } }
    ctx.restore();
    return {x:o.x, y:o.y-(o.size||24), w:maxW, h: lines*lineH};
  }
  return {x:o.x||0,y:o.y||0,w:o.w||0,h:o.h||0};
}
function hitObject(x,y){
  for(let i=objects.length-1;i>=0;i--){
    const b = getBounds(objects[i]);
    if(x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h) return i;
  }
  return -1;
}

async function pasteFromClipboard(){
  try{
    if(navigator.clipboard && navigator.clipboard.read){
      const items = await navigator.clipboard.read();
      for(const item of items){
        for(const type of item.types){
          if(type.startsWith('image/')){
            const blob = await item.getType(type);
            const img = new Image(); const url = URL.createObjectURL(blob);
            img.onload = ()=>{ objects.push({type:'image', img, x:60, y:60, w:Math.min(600,img.width), h:Math.min(400,img.height), locked:false}); URL.revokeObjectURL(url); render(); };
            img.src = url; return;
          }
        }
      }
      const text = await navigator.clipboard.readText();
      if(text){ objects.push({type:'textblock', text, x:60, y:80, w:600, color, size: Math.max(18, size), locked:false}); render(); return; }
    }
    alert('ç„¡æ³•ç›´æ¥è®€å–å‰ªè²¼ç°¿ï¼Œè«‹ä½¿ç”¨ Ctrl+V æ–¼ç•«å¸ƒä¸Šè²¼ä¸Šã€‚');
  }catch(err){ console.warn(err); alert('è®€å–å‰ªè²¼ç°¿å¤±æ•—ï¼Œè«‹æ”¹ç”¨ Ctrl+Vã€‚'); }
}

function handlePaste(e){
  const cd = e.clipboardData; if(!cd) return;
  for(const item of cd.items){
    if(item.type && item.type.startsWith('image/')){
      const file = item.getAsFile(); const img = new Image(); const url = URL.createObjectURL(file);
      img.onload = ()=>{ objects.push({type:'image', img, x:60, y:60, w:Math.min(600,img.width), h:Math.min(400,img.height), locked:false}); URL.revokeObjectURL(url); render(); };
      img.src = url; e.preventDefault(); return;
    }
  }
  const text = cd.getData('text/plain');
  if(text){ objects.push({type:'textblock', text, x:60, y:80, w:600, color, size: Math.max(18, size), locked:false}); render(); e.preventDefault(); }
}

function toggleLock(){ if(selected>=0){ objects[selected].locked = !objects[selected].locked; render(); } }

// é¸å–ç‰©ä»¶å¾Œå¯åˆªé™¤ï¼ˆæœªé–å®šï¼‰
window.addEventListener('keydown', (e)=>{
  if((e.key==='Delete' || e.key==='Backspace') && selected>=0){ const o = objects[selected]; if(!o.locked){ objects.splice(selected,1); selected=-1; render(); } }
});

// keyboard shortcuts
window.addEventListener('keydown', (e)=>{
  if(e.ctrlKey && e.key.toLowerCase()==='z'){ e.preventDefault(); undo(); }
  else if(e.ctrlKey && e.key.toLowerCase()==='y'){ e.preventDefault(); redo(); }
  else if(e.key.toLowerCase()==='f'){ toggleFullscreen(); }
  else {
    const keyMap = {p:'pen', h:'highlighter', e:'eraser', l:'line', r:'rect', t:'text', z:'laser'};
    const t = keyMap[e.key.toLowerCase()]; if(t){ setActiveTool(t); }
  }
});

// init
setActiveTool('pen');
resize();
</script>
</body>
</html>
